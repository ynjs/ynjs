{"version":3,"sources":["webpack://YNWebSocket/webpack/bootstrap","webpack://YNWebSocket/webpack/runtime/define property getters","webpack://YNWebSocket/webpack/runtime/hasOwnProperty shorthand","webpack://YNWebSocket/webpack/runtime/make namespace object","webpack://YNWebSocket/./src/EventEmitter.ts","webpack://YNWebSocket/./src/index.ts"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","handler","context","time","autoRemove","this","_events","Map","name","set","items","add","currentItem","EventItem","push","off","length","filter","item","on","callback","once","emit","eventName","arr","split","i","slice","join","forEach","apply","params","destory","clear","window","console","error","protocol","autoOpen","reconnectInterval","maxReconnectInterval","reconnectDecay","timeoutInterval","maxReconnectAttempts","binaryType","merge","newopt","url","options","isDebug","reconnectAttempts","socket","option","ReconnectingWebSocketOption","forcedClose","open","log","ReconnectingWebSocket","debugAll","args","debug","close","send","data","readyState","WebSocket","OPEN","Promise","resolve","then","sendnow","reject","onopen","event","onclose","onmessage","onerror","ex","onsocketclose","CLOSED"],"mappings":"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","file":"yn-WebSocket.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","type handler = (...args: any[])=>any\r\n\r\nclass EventItem {\r\n    handler:handler\r\n    time:number // 剩余次数 0 不触发\r\n    autoRemove: boolean // 剩余次数为0时自动移除\r\n    context?:any\r\n    constructor(handler:handler,context?:any,time:number = -1,autoRemove=true){\r\n        this.handler = handler\r\n        this.time = time;\r\n        this.context = context;\r\n        this.autoRemove = autoRemove;\r\n    }\r\n}\r\n\r\nexport default class EventEmitter {\r\n    // 所有订阅事件\r\n    private _events:Map<string,EventItem[]> = new Map()\r\n\r\n    constructor (){\r\n    }\r\n\r\n    private get(name:string){\r\n        return this._events.get(name);\r\n    }\r\n    private set(name:string,items:EventItem[]){\r\n        return this._events.set(name,items);\r\n    }\r\n    private add(name:string,handler:handler,context:any=null,time:number=-1){\r\n        let items = this.get(name);\r\n        let currentItem = new EventItem(handler,context,time);\r\n        if(items){\r\n            items.push(currentItem)\r\n        }else{\r\n            this.set(name,[currentItem])\r\n        }\r\n        return this;\r\n    }\r\n    off(name:string,handler:handler){\r\n        let items = this.get(name);\r\n        if(items && items.length){\r\n            if(handler){\r\n                this.set(name,items.filter(item=>item.handler==handler))\r\n            }else{\r\n                this.set(name,[])\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    on (name:string,callback:handler,context?:any){  //监听event事件，触发时调用callback函数\r\n        return this.add(name,callback,context)\r\n    }\r\n    once (name:string,callback:handler,context?:any){  //监听event事件，触发时调用callback函数\r\n        return this.add(name,callback,context,1)\r\n    }\r\n    emit (eventName:string,...params:any[]){ //触发事件，并把参数传给事件的处理函数\r\n        var arr = eventName.split(\":\");\r\n        for(var i=arr.length;i>0;i--){\r\n            const items = this.get(arr.slice(0,i).join(\":\"))||[]\r\n            items.forEach(item=>{\r\n                item.handler.apply(item.context||this,params)\r\n                if(item.time>1){item.time--;}\r\n            })\r\n            this.set(eventName,items.filter(item=>item.time === 0 && item.autoRemove))\r\n        }\r\n        return this\r\n    }\r\n    destory(){\r\n        this._events.clear();\r\n    }\r\n}","\r\nimport EventEmitter from \"./EventEmitter\"\r\n\r\nif (!('WebSocket' in window)) {\r\n    console.error(\"WebSocket no supper\")\r\n}\r\n\r\ninterface IReconnectingWebSocketOption {\r\n    autoOpen?:boolean\r\n}\r\n\r\nclass ReconnectingWebSocketOption implements ReconnectingWebSocketOption {\r\n    /** 指定协议 */\r\n    protocol:string = \"\"\r\n    /** 自动打开 */\r\n    autoOpen=true\r\n    /** 重连间隔时间 */\r\n    reconnectInterval=1000\r\n    /** 最大重连间隔时间 */\r\n    maxReconnectInterval=30000\r\n    /** 重新连接延迟的增加速率。允许重新连接尝试在问题持续时退出。 */\r\n    reconnectDecay=1.5\r\n    /** 在关闭并重试之前等待连接成功的最长时间（毫秒）。 */\r\n    timeoutInterval=2000\r\n    /** 尝试重新连接的最大次数。如果为空，则不受限制。 */\r\n    maxReconnectAttempts:null|number=null\r\n    /** 二进制类型，可能值“blob”或“arraybuffer”，默认值为“blob”。 */\r\n    binaryType:\"blob\"|\"arraybuffer\"='blob'\r\n\r\n    merge(newopt?:IReconnectingWebSocketOption){\r\n        if(!newopt){return this;}\r\n        if(newopt.autoOpen === false){ this.autoOpen = false; } \r\n        if(newopt.autoOpen === true){ this.autoOpen = true; }\r\n    }\r\n}\r\n\r\nexport default class ReconnectingWebSocket extends EventEmitter {\r\n    static debugAll = false;\r\n\r\n    /** 调试模式 */\r\n    isDebug=false\r\n    /** 连接地址 */\r\n    readonly url:string\r\n    \r\n    protocol:string=\"\"\r\n    // 当前重连次数\r\n    private reconnectAttempts = 0;\r\n    private socket:WebSocket|null = null;\r\n    private option = new ReconnectingWebSocketOption();\r\n    private forcedClose = false;\r\n    // 调试信息\r\n    private log(...args:any[]){\r\n        if (this.isDebug || ReconnectingWebSocket.debugAll) {\r\n            console.log(...args);\r\n        }else{\r\n            this.emit(\"log\",...args)\r\n        }\r\n    }\r\n    // 调试信息\r\n    private debug(...args:any[]){\r\n        if (this.isDebug || ReconnectingWebSocket.debugAll) {\r\n            console.debug(...args);\r\n        }\r\n    }\r\n    close(){\r\n        if(this.socket){\r\n            this.forcedClose = true\r\n            this.socket.close(1000,\"正常关闭\");\r\n            this.once(\"close\",function() {\r\n                \r\n            })\r\n        }\r\n    }\r\n    send(data:any){\r\n        if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n            this.debug('ReconnectingWebSocket', 'send', this.url, data);\r\n            this.socket.send(data);\r\n            return Promise.resolve(this.socket)\r\n        } else {\r\n            return this.open()\r\n            .then(socket=>{\r\n                console.debug('ReconnectingWebSocket', 'send', this.url, data);\r\n                this.socket && this.socket.send(data);\r\n            })\r\n        }\r\n    }\r\n    sendnow(data:any){\r\n        if(this.socket && this.socket.readyState === WebSocket.OPEN){\r\n            return this.socket.send(data);\r\n        }else {\r\n            throw '发送失败，socket 未准备好';\r\n        }\r\n    }\r\n    open(){\r\n        return createSocket(this.url)\r\n        .then(socket=>{\r\n            this.socket = socket;\r\n            this.emit(\"open\");\r\n            socket.onmessage = event=>{\r\n                this.emit(\"message\",event)\r\n            }\r\n            socket.onclose = event=>this.onsocketclose()\r\n            socket.onerror = event=>this.onsocketclose();\r\n            return this.socket;\r\n        })\r\n    }\r\n\r\n    // 当连接出现异常，调用此方法\r\n    private onsocketclose(){\r\n        if(!this.socket){return}\r\n\r\n        // 主动断开\r\n        if(this.forcedClose){\r\n            this.forcedClose = false;\r\n            this.socket.onmessage = null;\r\n            this.socket.onopen = null;\r\n            this.socket.onclose = null;\r\n            this.socket.onerror = null;\r\n            this.socket = null;\r\n            return;\r\n        }\r\n\r\n        if(this.socket.readyState === WebSocket.CLOSED){\r\n            if(this.option.maxReconnectAttempts){\r\n                if (this.reconnectAttempts > this.option.maxReconnectAttempts) {\r\n                    this.log(\"超过最大连接次数\")\r\n                    return;\r\n                }\r\n                this.reconnectAttempts++;\r\n            }\r\n            this.open().then(()=>{\r\n                this.emit(\"reconnent\")\r\n            });\r\n        }\r\n    }\r\n\r\n    constructor(url:string, options?:object){\r\n        super();\r\n        this.url = url;\r\n        this.option.merge(options)\r\n\r\n        if (this.option.autoOpen == true) {\r\n            this.open();\r\n        }\r\n    }\r\n}\r\n\r\nfunction createSocket(url:string,protocol?:string){\r\n    return new Promise<WebSocket>((resolve,reject)=>{\r\n        try{\r\n            let socket = new WebSocket(url, protocol);\r\n            socket.onopen = event=>{\r\n                console.log(\"onopen\");\r\n                resolve(socket);\r\n            }\r\n            socket.onclose = event=>console.log(\"onclose\");\r\n            socket.onmessage = event=>console.log(\"onmessage\");\r\n            socket.onerror = event=>console.log(\"onerror\");\r\n        }catch(ex){\r\n            reject(ex)\r\n        }\r\n    })\r\n}"],"sourceRoot":""}